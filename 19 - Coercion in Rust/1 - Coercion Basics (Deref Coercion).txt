// -------------------------------------------
// 	      Coercion
// -------------------------------------------

// Coercion: One_type -> Another_type (implicitly)

// pub trait Deref {
//     type Target: ?Sized;

//     fn deref(&self) -> &Self::Target;
// }

// Deref Coercion: &T -> &U
// if Deref Trait is implemented for T that convert &T to &U usind deref method
// &String -> &str

use std::ops::Deref;

fn accept_str(s: &str) {
    // either &str or &String
    println!("Recieved: {s}");
}

struct HtmlText {
    contents: String,
    is_escaped: bool,
}

impl Deref for HtmlText {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.contents
    }
}

fn print_length(s: &String) {
    println!("Length: {}", s.len());
}
fn main() {
    let s = String::from("Some String");
    accept_str(&s); // accept_str(s.deref())

    let html_input = HtmlText {
        contents: String::from("<b>Hello</b>"),
        is_escaped: false,
    };

    // Coercion: &HtmlText -> &String
    print_length(&html_input); // print_length(&html_input.deref())
    if html_input.contains("Hello") {
        println!("Found 'Hello' in HTML content!");
    }

    // Common Deref Coercions
    // 1. &String -> &str
    // 2. &Vec<T> -> &[T]
    // 3. &Box<T> ->  &T

    // 2. &Vec<T> -> &[T]
    let array: &[i32];
    let vec = &vec![1, 2, 3];
    array = vec;

    // 3. &Box<T> ->  &T
    let i: &i32;
    let value = Box::new(5);
    i = &value;
}
// DerefMut trait implementation for T, enables &mut T to &mut U
// 1. &mut String -> &mut str
// 2. &mut Vec<T> -> &mut [T]
// 3. &mut Box<T> -> &mut T
