// -------------------------------------------
// 	        Anyhow
// -------------------------------------------

use anyhow::{Context, Result};
use std::{fs::File, io::Error, io::Read, num::ParseIntError};

// #[derive(Debug)]
// enum AppError {
//     Io(Error),
//     Parse(ParseIntError),
// }

// impl From<Error> for AppError {
//     fn from(value: Error) -> Self {
//         Self::Io(value)
//     }
// }

// impl From<ParseIntError> for AppError {
//     fn from(value: ParseIntError) -> Self {
//         Self::Parse(value)
//     }
// }

// Result<i32> = Result<i32, anyhow::Error>
fn read_and_parse_number(file_path: String) -> Result<i32> {
    let mut file = File::open(file_path).context("Failed to read file contents")?;

    let mut contents = String::new();
    file.read_to_string(&mut contents)?;

    let number = contents
        .trim()
        .parse::<i32>()
        .with_context(|| format!("Failed to parse integer from contents: {}", contents.trim()))?;
    Ok(number)
}
fn main() {
    let file = String::from("number.txt");
    match read_and_parse_number(file) {
        Ok(number) => println!("File contains number: {}", number),
        Err(e) => println!("Cannot process: {:?}", e),
    }
}

/*
Code without anyhow                         || Code with anyhow
For functions returning multiple            || Eliminates the need for Custom
error type with error propagation,          || error types not required
custom Error types are required

Requires manual conversion                  || No need for manual conversion
using `From` trait

Return type `Result<i32, Customtype>        || Result<i32>
Simple Error propagation                    || Error propagation enriched with context
*/
