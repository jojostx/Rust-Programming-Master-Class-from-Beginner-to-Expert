// -------------------------------------------
// 	      Transitivity in Coercion
// -------------------------------------------

// A -> B and B -> C then A -> C

use std::ops::Deref;

struct Book {
    name: String,
    authors: String,
    publication_year: u32,
}

impl Deref for Book {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.name
    }
}

fn print_str(s: &str) {
    println!("{}", s);
}
fn main() {
    let my_book = Book {
        name: String::from("Rust Programming"),
        authors: String::from("Nouman Azam"),
        publication_year: 2020,
    };

    // Transitive Deref Coercion Chain:
    // &Book -> &String -> &str

    // my_book.deref() -> &String
    // my_book.deref().deref() -> &str

    // &Box<Book> -> &Book -> &String -> &str
    print_str(&Box::new(my_book));
}
